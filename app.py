# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Vz5rbna_foPy44zQLxVdQByheqckOjgP
"""

import streamlit as st
import requests
import json
import time
import pandas as pd
import re
from plotly.subplots import make_subplots
import plotly.graph_objects as go
import plotly.express as px
from typing import Dict, Any, Optional, Union
import logging
from datetime import datetime
import hashlib

# Configuration with environment variable support
API_KEY = st.secrets.get("OPENROUTER_API_KEY", "sk-or-default-fallback")
API_URL = "https://openrouter.ai/api/v1/chat/completions"
MODEL = "mistralai/mistral-nemo:free"

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class PhoneDataManager:
    """Enhanced data manager with better error handling and caching"""

    def __init__(self):
        self.df = None
        self.data_loaded = False

    @st.cache_data
    def load_phone_data(_self) -> pd.DataFrame:
        """Load and preprocess mobile phone data with comprehensive error handling"""
        try:
            # Try multiple possible file locations
            possible_files = [
                "Mobiles Dataset (2025).csv",
                "data/Mobiles Dataset (2025).csv",
                "dataset/Mobiles Dataset (2025).csv"
            ]

            df = None
            for file_path in possible_files:
                try:
                    df = pd.read_csv(file_path, encoding="ISO-8859-1")
                    break
                except FileNotFoundError:
                    continue

            if df is None:
                st.error("❌ Dataset tidak ditemukan! Pastikan file 'Mobiles Dataset (2025).csv' ada di direktori yang benar.")
                return _self._create_sample_data()

        except Exception as e:
            st.error(f"❌ Error loading dataset: {str(e)}")
            return _self._create_sample_data()

        return _self._preprocess_data(df)

    def _create_sample_data(self) -> pd.DataFrame:
        """Create sample data for demonstration purposes"""
        sample_data = {
            'Company Name': ['Samsung', 'Apple', 'Xiaomi', 'OnePlus', 'Google'],
            'Model Name': ['Galaxy S23', 'iPhone 14', 'Mi 13', '11 Pro', 'Pixel 7'],
            'RAM': ['8 GB', '6 GB', '12 GB', '8 GB', '8 GB'],
            'Back Camera': ['50MP + 12MP + 10MP', '48MP + 12MP', '50MP + 50MP + 50MP', '50MP + 48MP + 32MP', '50MP + 12MP'],
            'Battery Capacity': ['3,900 mAh', '3,279 mAh', '4,500 mAh', '5,000 mAh', '4,355 mAh'],
            'Launched Price (USA)': ['USD 799', 'USD 899', 'USD 649', 'USD 749', 'USD 599'],
            'Mobile Weight': ['168 g', '172 g', '189 g', '205 g', '197 g'],
            'Screen Size': ['6.1 inches', '6.1 inches', '6.36 inches', '6.7 inches', '6.3 inches'],
            'Launched Year': [2023, 2022, 2023, 2023, 2022]
        }

        st.warning("⚠️ Menggunakan data sampel karena dataset utama tidak ditemukan.")
        return pd.DataFrame(sample_data)

    def _preprocess_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """Enhanced data preprocessing with better error handling"""
        try:
            # Create a copy to avoid modifying original data
            df = df.copy()

            # Extract RAM values with better regex
            df["RAM"] = df["RAM"].astype(str).str.extract(r"(\d+(?:\.\d+)?)").astype(float)

            # Extract camera megapixels with improved logic
            def extract_max_camera(text):
                if pd.isna(text) or text == 'nan':
                    return 0
                try:
                    numbers = re.findall(r"(\d+(?:\.\d+)?)(?:\s*MP|mp)", str(text), re.IGNORECASE)
                    return max(map(float, numbers)) if numbers else 0
                except:
                    return 0

            df["Back Camera MP"] = df["Back Camera"].apply(extract_max_camera)

            # Extract battery capacity with better handling
            def extract_battery(text):
                if pd.isna(text) or text == 'nan':
                    return 0
                try:
                    # Remove commas and extract numbers
                    clean_text = str(text).replace(",", "").replace(".", "")
                    numbers = re.findall(r"(\d+)", clean_text)
                    # Find the largest number (likely to be mAh)
                    return max(map(int, numbers)) if numbers else 0
                except:
                    return 0

            df["Battery Extracted"] = df["Battery Capacity"].apply(extract_battery)

            # Enhanced price extraction and conversion
            def extract_price(text):
                if pd.isna(text) or text == 'nan':
                    return 0
                try:
                    # Remove USD, commas, and extract number
                    clean_text = str(text).replace("USD", "").replace(",", "").strip()
                    price_match = re.search(r"(\d+(?:\.\d+)?)", clean_text)
                    return float(price_match.group(1)) if price_match else 0
                except:
                    return 0

            df["Price USD"] = df["Launched Price (USA)"].apply(extract_price)
            df["Price"] = df["Price USD"] * 16000  # Convert to IDR

            # Extract weight and screen size with better handling
            df["Weight"] = df["Mobile Weight"].astype(str).str.extract(r"(\d+(?:\.\d+)?)").astype(float)
            df["Screen Size"] = df["Screen Size"].astype(str).str.extract(r"(\d+(?:\.\d+)?)").astype(float)

            # Ensure Launched Year is integer
            df["Launched Year"] = pd.to_numeric(df["Launched Year"], errors='coerce').fillna(2020).astype(int)

            # Remove rows with missing critical data
            critical_columns = ['RAM', 'Price', 'Battery Extracted']
            df = df.dropna(subset=critical_columns)

            # Remove outliers (optional)
            df = self._remove_outliers(df)

            logger.info(f"Data preprocessing completed. Final dataset shape: {df.shape}")
            return df

        except Exception as e:
            st.error(f"❌ Error preprocessing data: {str(e)}")
            return pd.DataFrame()

    def _remove_outliers(self, df: pd.DataFrame) -> pd.DataFrame:
        """Remove obvious outliers from the dataset"""
        # Remove phones with unrealistic specs
        df = df[df['RAM'] <= 32]  # Max 32GB RAM
        df = df[df['Battery Extracted'] <= 10000]  # Max 10000mAh battery
        df = df[df['Price'] <= 50000000]  # Max 50M IDR
        df = df[df['Weight'] <= 500]  # Max 500g weight
        df = df[df['Screen Size'] <= 10]  # Max 10 inch screen

        return df

class SmartFilter:
    """Enhanced filtering system with better logic"""

    @staticmethod
    def progressive_filter(df: pd.DataFrame, column: str, min_results: int = 20, descending: bool = True) -> pd.DataFrame:
        """Enhanced progressive filtering"""
        if df.empty or column not in df.columns:
            return df

        # Sort by the column and take top results
        df_sorted = df.sort_values(by=column, ascending=not descending, na_position='last')
        return df_sorted.head(min_results)

    @staticmethod
    def apply_numeric_filter(df: pd.DataFrame, column: str, filter_value: Union[int, float, Dict[str, Any]]) -> pd.DataFrame:
        """Apply numeric filters with better handling"""
        if isinstance(filter_value, dict):
            if "lte" in filter_value:
                df = df[df[column] <= filter_value["lte"]]
            if "gte" in filter_value:
                df = df[df[column] >= filter_value["gte"]]
            if "approx" in filter_value:
                target = filter_value["approx"]
                tolerance = 0.15  # 15% tolerance
                df = df[(df[column] >= target * (1 - tolerance)) &
                       (df[column] <= target * (1 + tolerance))]
        elif isinstance(filter_value, (int, float)):
            df = df[df[column] >= filter_value]

        return df

    def filter_phones(self, df: pd.DataFrame, **kwargs) -> pd.DataFrame:
        """Enhanced phone filtering with better logic"""
        if df.empty:
            return df

        # Create a copy to avoid modifying original
        filtered_df = df.copy()
        min_results = kwargs.get('min_results', 10)

        # Filter mapping for better organization
        filters = {
            'ram': ('RAM', 'high'),
            'camera': ('Back Camera MP', 'good'),
            'battery': ('Battery Extracted', 'big'),
            'price': ('Price', None),
            'weight': ('Weight', 'light'),
            'screen': ('Screen Size', 'large'),
            'year': ('Launched Year', 'latest')
        }

        for param, (column, good_value) in filters.items():
            if param not in kwargs or kwargs[param] is None:
                continue

            value = kwargs[param]

            if isinstance(value, dict) or isinstance(value, (int, float)):
                filtered_df = self.apply_numeric_filter(filtered_df, column, value)
            elif value == good_value:
                filtered_df = self.progressive_filter(filtered_df, column, min_results, descending=True)
            elif param == 'price' and value in ['low', 'cheap']:
                filtered_df = filtered_df.sort_values(by=column, ascending=True)
            elif param == 'price' and value == 'high':
                filtered_df = filtered_df.sort_values(by=column, ascending=False)
            elif param == 'weight' and value == 'light':
                filtered_df = filtered_df.sort_values(by=column, ascending=True)

        return filtered_df.head(min_results)

class AIRecommendationEngine:
    """Enhanced AI recommendation engine"""

    def __init__(self, api_key: str, api_url: str, model: str):
        self.api_key = api_key
        self.api_url = api_url
        self.model = model
        self.cache = {}

    def _get_cache_key(self, text: str) -> str:
        """Generate cache key for request"""
        return hashlib.md5(text.encode()).hexdigest()

    def extract_json_robust(self, text: str) -> str:
        """Enhanced JSON extraction with better error handling"""
        try:
            # Multiple patterns to try
            patterns = [
                r'\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}',  # Nested JSON
                r'\{.*?\}',  # Simple JSON
                r'```json\s*(\{.*?\})\s*```',  # Code block JSON
            ]

            for pattern in patterns:
                matches = re.findall(pattern, text, re.DOTALL)
                for match in matches:
                    try:
                        # Clean the JSON string
                        json_str = match.strip()
                        json_str = json_str.replace("'", '"')
                        json_str = re.sub(r',\s*}', '}', json_str)
                        json_str = re.sub(r',\s*]', ']', json_str)

                        # Test if it's valid JSON
                        json.loads(json_str)
                        return json_str
                    except json.JSONDecodeError:
                        continue

            raise ValueError("No valid JSON found in text")

        except Exception as e:
            raise ValueError(f"Failed to extract JSON: {str(e)}")

    def query_with_retry(self, user_input: str, allowed_keys: list, max_retries: int = 3) -> Dict[str, Any]:
        """Enhanced query with better retry logic and caching"""

        # Check cache first
        cache_key = self._get_cache_key(user_input)
        if cache_key in self.cache:
            return self.cache[cache_key]

        prompt_template = self._create_enhanced_prompt(user_input)

        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

        for attempt in range(max_retries):
            try:
                body = {
                    "model": self.model,
                    "messages": [
                        {"role": "system", "content": "Kamu adalah asisten AI yang ahli dalam menganalisis kebutuhan pengguna untuk rekomendasi handphone. Selalu kembalikan response dalam format JSON yang valid."},
                        {"role": "user", "content": prompt_template}
                    ],
                    "temperature": 0.3,  # Lower temperature for more consistent results
                    "max_tokens": 500
                }

                response = requests.post(self.api_url, headers=headers,
                                       data=json.dumps(body), timeout=20)

                if response.status_code == 200:
                    data = response.json()
                    if "choices" in data and len(data["choices"]) > 0:
                        raw_output = data["choices"][0]["message"]["content"]

                        try:
                            json_str = self.extract_json_robust(raw_output)
                            params = json.loads(json_str)

                            # Validate and clean parameters
                            cleaned_params = {k: v for k, v in params.items() if k in allowed_keys}

                            if cleaned_params:
                                # Cache the result
                                self.cache[cache_key] = cleaned_params
                                return cleaned_params

                        except Exception as e:
                            logger.warning(f"JSON parsing error on attempt {attempt + 1}: {str(e)}")

                elif response.status_code == 429:  # Rate limit
                    wait_time = 2 ** attempt  # Exponential backoff
                    time.sleep(wait_time)
                    continue
                else:
                    logger.warning(f"API Error {response.status_code} on attempt {attempt + 1}")

                time.sleep(1)  # Brief pause between attempts

            except requests.exceptions.Timeout:
                logger.warning(f"Timeout on attempt {attempt + 1}")
                time.sleep(2)
            except Exception as e:
                logger.warning(f"Request error on attempt {attempt + 1}: {str(e)}")
                time.sleep(1)

        # Enhanced fallback with keyword analysis
        return self._create_smart_fallback(user_input)

    def _create_enhanced_prompt(self, user_input: str) -> str:
        """Create more comprehensive prompt"""
        return f'''
Analisis kebutuhan user dan konversi ke parameter JSON untuk fungsi filter_hp().

ATURAN PARAMETER:
- ram: angka (4,6,8,12,16) atau "high"
- camera: "good" atau angka MP
- battery: "big" atau angka mAh
- price: "low"/"high" atau {{lte: X}}/{{gte: X}}/{{approx: X}}
- weight: "light" atau angka gram
- screen: "large" atau angka inci
- year: "latest" atau {{lte: X}}/{{gte: X}}/{{approx: X}}

CONTOH KONVERSI:
"HP gaming RAM 8GB harga 5 juta" → {{"ram": 8, "price": {{"approx": 5000000}}}}
"Smartphone murah kamera bagus" → {{"price": "low", "camera": "good"}}
"HP flagship terbaru" → {{"ram": "high", "camera": "good", "battery": "big", "year": "latest"}}
"HP di bawah 3 juta ringan" → {{"price": {{"lte": 3000000}}, "weight": "light"}}

USER INPUT: "{user_input}"

RESPONSE (JSON only):
'''

    def _create_smart_fallback(self, user_input: str) -> Dict[str, Any]:
        """Create intelligent fallback based on keyword analysis"""
        fallback_params = {}
        user_lower = user_input.lower()

        # Enhanced keyword mapping
        keyword_mappings = {
            'camera': (['kamera', 'camera', 'foto', 'photo', 'selfie', 'potret'], 'good'),
            'battery': (['baterai', 'battery', 'tahan lama', 'awet', 'daya tahan'], 'big'),
            'ram': (['ram', 'memory', 'gaming', 'cepat', 'performa', 'multitask'], 'high'),
            'price': (['murah', 'budget', 'terjangkau', 'hemat', 'ekonomis'], 'low'),
            'weight': (['ringan', 'light', 'portable', 'travel'], 'light'),
            'screen': (['layar', 'screen', 'besar', 'lebar', 'wide'], 'large'),
            'year': (['terbaru', 'latest', 'baru', 'new', 'fresh'], 'latest')
        }

        for param, (keywords, value) in keyword_mappings.items():
            if any(keyword in user_lower for keyword in keywords):
                fallback_params[param] = value

        # Extract specific numbers
        price_match = re.search(r'(\d+(?:\.\d+)?)\s*(?:juta|million)', user_lower)
        if price_match:
            price_val = float(price_match.group(1)) * 1000000
            fallback_params['price'] = {"approx": price_val}

        ram_match = re.search(r'(\d+)\s*gb.*ram|ram\s*(\d+)\s*gb', user_lower)
        if ram_match:
            ram_val = int(ram_match.group(1) or ram_match.group(2))
            fallback_params['ram'] = ram_val

        return fallback_params

    def generate_recommendation_summary(self, params: Dict[str, Any], df: pd.DataFrame) -> str:
        """Generate AI-powered recommendation summary"""
        if len(df) < 2:
            return "Rekomendasi HP terbaik berdasarkan kriteria Anda!"

        top_phones = df.head(2).apply(
            lambda row: f"{row['Company Name']} {row['Model Name']}", axis=1
        ).tolist()

        prompt = f"""
Buat kalimat rekomendasi yang menarik dan personal untuk 2 HP berikut:
1. {top_phones[0]}
2. {top_phones[1]}

Berdasarkan kriteria: {params}

Kalimat harus:
- Ramah dan personal
- Menyebut kedua HP
- 2-3 kalimat maksimal
- Bahasa Indonesia yang natural

Contoh: "Berdasarkan kebutuhan Anda, saya merekomendasikan {top_phones[0]} dan {top_phones[1]} sebagai pilihan terbaik yang sesuai budget dan spesifikasi yang diinginkan."
"""

        try:
            # Use same API call pattern but with different prompt
            headers = {"Authorization": f"Bearer {self.api_key}", "Content-Type": "application/json"}
            body = {
                "model": self.model,
                "messages": [
                    {"role": "system", "content": "Kamu adalah asisten rekomendasi yang ramah dan membantu."},
                    {"role": "user", "content": prompt}
                ],
                "temperature": 0.7,
                "max_tokens": 150
            }

            response = requests.post(self.api_url, headers=headers, data=json.dumps(body), timeout=10)
            if response.status_code == 200:
                return response.json()["choices"][0]["message"]["content"].strip()
        except:
            pass

        return f"Berdasarkan kriteria Anda, saya merekomendasikan {' dan '.join(top_phones)} sebagai pilihan terbaik!"

class VisualizationEngine:
    """Enhanced visualization with better charts"""

    @staticmethod
    def create_comparison_chart(df: pd.DataFrame) -> None:
        """Create enhanced comparison chart with better error handling"""
        try:
            if len(df) < 2:
                st.warning("Butuh minimal 2 HP untuk dibandingkan.")
                return

            # Take top 3 phones for comparison
            top_phones = df.head(3)

            features = ["RAM", "Back Camera MP", "Battery Extracted", "Price", "Weight", "Screen Size"]
            labels = ["RAM (GB)", "Kamera (MP)", "Baterai (mAh)", "Harga (IDR)", "Berat (g)", "Layar (inci)"]

            # Create subplots
            fig = make_subplots(
                rows=2, cols=3,
                subplot_titles=labels,
                specs=[[{"secondary_y": False} for _ in range(3)] for _ in range(2)]
            )

            colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD']

            for i, (feature, label) in enumerate(zip(features, labels)):
                row = (i // 3) + 1
                col = (i % 3) + 1

                for idx, (_, phone) in enumerate(top_phones.iterrows()):
                    phone_name = f"{phone['Company Name']} {phone['Model Name']}"
                    value = phone[feature] if pd.notna(phone[feature]) else 0

                    # Format value based on feature type
                    if feature == "Price":
                        display_value = f"{value/1000000:.1f}M"
                    else:
                        display_value = f"{value:.0f}"

                    fig.add_trace(
                        go.Bar(
                            x=[phone_name[:15] + "..." if len(phone_name) > 15 else phone_name],
                            y=[value],
                            name=phone_name if i == 0 else None,
                            marker_color=colors[idx % len(colors)],
                            text=display_value,
                            textposition='auto',
                            showlegend=(i == 0),
                            legendgroup=f"phone_{idx}"
                        ),
                        row=row, col=col
                    )

            fig.update_layout(
                title_text='📊 Perbandingan Spesifikasi Detail',
                height=600,
                showlegend=True,
                template='plotly_white',
                legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
            )

            # Update x-axis to prevent overlapping labels
            fig.update_xaxes(tickangle=45)

            st.plotly_chart(fig, use_container_width=True)

        except Exception as e:
            st.error(f"Error creating comparison chart: {str(e)}")
            st.info("Menampilkan data dalam format tabel sebagai alternatif:")
            
            # Fallback table display
            comparison_data = df.head(3)[['Company Name', 'Model Name', 'RAM', 'Back Camera MP', 
                                        'Battery Extracted', 'Price', 'Weight', 'Screen Size']]
            st.dataframe(comparison_data)

    @staticmethod
    def create_price_performance_scatter(df: pd.DataFrame) -> None:
        """Create price vs performance scatter plot with error handling"""
        try:
            if len(df) < 5:
                return

            # Calculate performance score
            df_viz = df.copy()
            df_viz['Performance Score'] = (
                df_viz['RAM'] * 0.3 +
                df_viz['Back Camera MP'] * 0.2 +
                df_viz['Battery Extracted'] / 100 * 0.3 +
                (2025 - df_viz['Launched Year']) * -2 * 0.2  # Newer is better
            )

            fig = px.scatter(
                df_viz.head(15),
                x='Price',
                y='Performance Score',
                size='Screen Size',
                color='Company Name',
                hover_name='Model Name',
                hover_data=['RAM', 'Back Camera MP', 'Battery Extracted'],
                title='📈 Analisis Harga vs Performa',
                labels={
                    'Price': 'Harga (IDR)',
                    'Performance Score': 'Skor Performa'
                }
            )

            fig.update_layout(template='plotly_white', height=500)
            st.plotly_chart(fig, use_container_width=True)

        except Exception as e:
            st.error(f"Error creating scatter plot: {str(e)}")
            st.info("Scatter plot tidak dapat ditampilkan karena keterbatasan data.")

def main():
    """Enhanced main application"""
    st.set_page_config(
        page_title="PickAPhone - AI Phone Recommendations",
        page_icon="📱",
        layout="wide",
        initial_sidebar_state="expanded"
    )

    # Enhanced CSS styling
    st.markdown("""
        <style>
        .main {background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh;}
        .stApp > header {background-color: transparent;}

        .card {
            background: white;
            border-radius: 15px;
            padding: 2rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            margin: 1rem 0;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .metric-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            padding: 1.5rem;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .stButton>button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 0.75rem 2rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .stButton>button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .header-text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 3rem !important;
            font-weight: 800 !important;
            text-align: center;
            margin-bottom: 2rem;
        }

        .phone-card {
            background: white;
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
            border-left: 4px solid #667eea;
        }

        .phone-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
        }
        </style>
    """, unsafe_allow_html=True)

    # Initialize components
    data_manager = PhoneDataManager()
    smart_filter = SmartFilter()
    ai_engine = AIRecommendationEngine(API_KEY, API_URL, MODEL)
    viz_engine = VisualizationEngine()

    # Sidebar
    with st.sidebar:
        st.markdown("# 📱 PickAPhone AI")
        st.markdown("---")

        page = st.radio(
            "Pilih Menu",
            ["🏠 Dashboard", "🔍 Cari HP", "📊 Analytics", "ℹ️ About"],
            label_visibility="collapsed"
        )

        st.markdown("---")
        st.markdown("### 🚀 Fitur Terbaru")
        st.markdown("""
        - ✨ AI-Powered Search
        - 📊 Advanced Analytics
        - 🔄 Real-time Comparison
        - 💡 Smart Recommendations
        """)

    # Load data once
    df = data_manager.load_phone_data()

    if page == "🏠 Dashboard":
        render_dashboard(df)
    elif page == "🔍 Cari HP":
        render_search_page(df, smart_filter, ai_engine, viz_engine)
    elif page == "📊 Analytics":
        render_analytics_page(df, viz_engine)
    else:
        render_about_page()

def render_dashboard(df: pd.DataFrame):
    """Render enhanced dashboard"""
    st.markdown('<p class="header-text">Dashboard PickAPhone</p>', unsafe_allow_html=True)

    if df.empty:
        st.error("Data tidak tersedia.")
        return

    # Key metrics
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.markdown(f"""
        <div class="metric-card">
            <h3>📱 {len(df)}</h3>
            <p>Total Handphone</p>
        </div>
        """, unsafe_allow_html=True)

    with col2:
        st.markdown(f"""
        <div class="metric-card">
            <h3>🏭 {df['Company Name'].nunique()}</h3>
            <p>Brand Tersedia</p>
        </div>
        """, unsafe_allow_html=True)

    with col3:
        st.markdown(f"""
        <div class="metric-card">
            <h3>📅 {df['Launched Year'].max()}</h3>
            <p>Tahun Terbaru</p>
        </div>
        """, unsafe_allow_html=True)

    with col4:
        avg_price = df['Price'].mean()
        st.markdown(f"""
        <div class="metric-card">
            <h3>💰 {avg_price/1000000:.1f}M</h3>
            <p>Rata-rata Harga</p>
        </div>
        """, unsafe_allow_html=True)

    # Popular phones section
    st.markdown("## 🔥 HP Terpopuler")

    # Get top phones by different criteria
    tab1, tab2, tab3, tab4 = st.tabs(["💰 Termurah", "⚡ Performa Tinggi", "📸 Kamera Terbaik", "🔋 Baterai Awet"])

    with tab1:
        cheap_phones = df.nsmallest(5, 'Price')
        display_phone_cards(cheap_phones)

    with tab2:
        performance_phones = df.nlargest(5, 'RAM')
        display_phone_cards(performance_phones)

    with tab3:
        camera_phones = df.nlargest(5, 'Back Camera MP')
        display_phone_cards(camera_phones)

    with tab4:
        battery_phones = df.nlargest(5, 'Battery Extracted')
        display_phone_cards(battery_phones)

def render_search_page(df: pd.DataFrame, smart_filter: SmartFilter, ai_engine: AIRecommendationEngine, viz_engine: VisualizationEngine):
    """Render enhanced search page"""
    st.markdown('<p class="header-text">🔍 Cari HP Impian Anda</p>', unsafe_allow_html=True)

    if df.empty:
        st.error("Data tidak tersedia untuk pencarian.")
        return

    # Search methods
    search_method = st.radio(
        "Pilih Metode Pencarian:",
        ["💬 Pencarian AI (Natural Language)", "⚙️ Filter Manual"],
        horizontal=True
    )

    if search_method == "💬 Pencarian AI (Natural Language)":
        render_ai_search(df, smart_filter, ai_engine, viz_engine)
    else:
        render_manual_filter(df, smart_filter, viz_engine)

def render_ai_search(df: pd.DataFrame, smart_filter: SmartFilter, ai_engine: AIRecommendationEngine, viz_engine: VisualizationEngine):
    """Render AI-powered search interface"""
    st.markdown("### 🤖 Pencarian dengan AI")

    # Perbaikan: Inisialisasi session state yang lebih konsisten
    if 'ai_search_results' not in st.session_state:
        st.session_state.ai_search_results = pd.DataFrame()
    if 'ai_search_applied' not in st.session_state:
        st.session_state.ai_search_applied = False
    if 'ai_query' not in st.session_state:
        st.session_state.ai_query = ""
    # Tambahan: session state untuk menyimpan parameter AI
    if 'ai_params' not in st.session_state:
        st.session_state.ai_params = {}
    if 'ai_recommendation_text' not in st.session_state:
        st.session_state.ai_recommendation_text = ""

    st.markdown("Jelaskan kebutuhan HP Anda dalam bahasa natural, AI akan memahami dan memberikan rekomendasi terbaik!")

    # Example queries
    with st.expander("💡 Contoh Pencarian"):
        st.markdown("""
        **Contoh query yang bisa Anda gunakan:**
        - "HP gaming RAM 8GB harga di bawah 5 juta"
        - "Smartphone murah tapi kamera bagus untuk fotografi"
        - "HP flagship terbaru dengan baterai awet"
        - "Handphone ringan untuk travel di bawah 3 juta"
        - "HP untuk content creator dengan kamera 50MP"
        """)

    # Search input
    user_query = st.text_input(
        "Masukkan kebutuhan HP Anda:",
        placeholder="Contoh: HP gaming RAM 8GB harga 5 juta",
        help="Jelaskan spesifikasi, budget, atau kebutuhan khusus Anda"
    )

    col1, col2 = st.columns([1, 4])
    with col1:
        search_button = st.button("🔍 Cari HP", type="primary")

    if search_button and user_query:
        with st.spinner("🧠 AI sedang menganalisis kebutuhan Anda..."):
            # Extract parameters using AI
            allowed_keys = ['ram', 'camera', 'battery', 'price', 'weight', 'screen', 'year', 'min_results']
            extracted_params = ai_engine.query_with_retry(user_query, allowed_keys)

            if extracted_params:
                st.success("✅ AI berhasil memahami kebutuhan Anda!")

                # Show extracted parameters
                with st.expander("🔍 Parameter yang terdeteksi"):
                    st.json(extracted_params)

                # Apply filters
                filtered_df = smart_filter.filter_phones(df, **extracted_params)

                if not filtered_df.empty:
                    # Generate AI recommendation summary
                    recommendation_text = ai_engine.generate_recommendation_summary(extracted_params, filtered_df)
                    
                    # Perbaikan: Simpan semua hasil dalam session state
                    st.session_state.ai_search_results = filtered_df
                    st.session_state.ai_search_applied = True
                    st.session_state.ai_query = user_query
                    st.session_state.ai_params = extracted_params
                    st.session_state.ai_recommendation_text = recommendation_text

                    st.markdown(f"### 💡 Rekomendasi AI")
                    st.info(recommendation_text)

                else:
                    st.warning("❌ Tidak ada HP yang sesuai dengan kriteria Anda. Coba ubah parameter pencarian.")
                    # Reset session state jika tidak ada hasil
                    st.session_state.ai_search_applied = False
                    st.session_state.ai_search_results = pd.DataFrame()
            else:
                st.error("❌ Maaf, AI tidak dapat memahami permintaan Anda. Silakan coba dengan kalimat yang lebih spesifik.")
                # Reset session state jika AI gagal memahami
                st.session_state.ai_search_applied = False
                st.session_state.ai_search_results = pd.DataFrame()

    # Perbaikan: Tampilkan hasil jika sudah ada pencarian sebelumnya
    if st.session_state.ai_search_applied and not st.session_state.ai_search_results.empty:
        # Tampilkan rekomendasi AI jika ada
        if st.session_state.ai_recommendation_text:
            st.markdown(f"### 💡 Rekomendasi AI")
            st.info(st.session_state.ai_recommendation_text)
        
        display_search_results(st.session_state.ai_search_results, viz_engine, st.session_state.ai_query)

def render_manual_filter(df: pd.DataFrame, smart_filter: SmartFilter, viz_engine: VisualizationEngine):
    """Render manual filter interface with fixed state management"""
    st.markdown("### ⚙️ Filter Manual")

    # Initialize session state for filters if not exists
    if 'filter_applied' not in st.session_state:
        st.session_state.filter_applied = False
    if 'filtered_results' not in st.session_state:
        st.session_state.filtered_results = pd.DataFrame()
    if 'filter_params' not in st.session_state:
        st.session_state.filter_params = {}

    with st.form("manual_filter_form"):
        col1, col2, col3 = st.columns(3)

        with col1:
            st.markdown("**💾 Memori & Performa**")
            ram_filter = st.selectbox("RAM Minimum", [None, 4, 6, 8, 12, 16], format_func=lambda x: f"{x} GB" if x else "Semua")

            st.markdown("**📅 Tahun Rilis**")
            year_range = st.slider("Tahun", 2018, 2025, (2020, 2025))

        with col2:
            st.markdown("**💰 Budget**")
            budget_type = st.radio("Tipe Budget", ["Range", "Maksimal"], horizontal=True)

            if budget_type == "Range":
                price_range = st.slider("Range Harga (Juta IDR)", 1, 50, (5, 20))
                min_price, max_price = price_range[0] * 1000000, price_range[1] * 1000000
            else:
                max_budget = st.number_input("Budget Maksimal (Juta IDR)", 1, 50, 10)
                min_price, max_price = 0, max_budget * 1000000

        with col3:
            st.markdown("**📱 Spesifikasi Lain**")
            camera_min = st.number_input("Kamera Minimum (MP)", 0, 200, 12)
            battery_min = st.number_input("Baterai Minimum (mAh)", 2000, 6000, 3000)
            screen_min = st.number_input("Layar Minimum (inci)", 4.0, 8.0, 5.5, 0.1)

        submitted = st.form_submit_button("🔍 Terapkan Filter", type="primary")

    if submitted:
        # Apply manual filters
        filtered_df = df[
            (df['RAM'] >= (ram_filter or 0)) &
            (df['Price'] >= min_price) &
            (df['Price'] <= max_price) &
            (df['Back Camera MP'] >= camera_min) &
            (df['Battery Extracted'] >= battery_min) &
            (df['Screen Size'] >= screen_min) &
            (df['Launched Year'] >= year_range[0]) &
            (df['Launched Year'] <= year_range[1])
        ].sort_values('Price')

        # Store results in session state
        st.session_state.filtered_results = filtered_df
        st.session_state.filter_applied = True
        st.session_state.filter_params = {
            'ram': ram_filter,
            'price_range': (min_price, max_price),
            'camera': camera_min,
            'battery': battery_min,
            'screen': screen_min,
            'year_range': year_range
        }

    # Display results if filter has been applied
    if st.session_state.filter_applied and not st.session_state.filtered_results.empty:
        display_search_results(st.session_state.filtered_results, viz_engine, "Filter Manual")
    elif st.session_state.filter_applied and st.session_state.filtered_results.empty:
        st.warning("❌ Tidak ada HP yang sesuai dengan filter Anda. Coba ubah kriteria pencarian.")

def display_search_results(df: pd.DataFrame, viz_engine: VisualizationEngine, query: str):
    """Display search results with enhanced formatting - FIXED VERSION"""
    st.markdown(f"### 📱 Hasil Pencarian ({len(df)} HP ditemukan)")
    
    # Results summary
    col1, col2, col3 = st.columns(3)
    with col1:
        st.metric("Total HP", len(df))
    with col2:
        avg_price = df['Price'].mean()
        st.metric("Rata-rata Harga", f"Rp {avg_price/1000000:.1f}M")
    with col3:
        price_range = df['Price'].max() - df['Price'].min()
        st.metric("Range Harga", f"Rp {price_range/1000000:.1f}M")
    
    # Perbaikan: Gunakan key yang unik dan konsisten berdasarkan query dan jumlah hasil
    import hashlib
    # Buat key yang unik berdasarkan query dan hash dari dataframe
    df_hash = hashlib.md5(str(df.shape).encode()).hexdigest()[:8]
    query_hash = hashlib.md5(str(query).encode()).hexdigest()[:8]
    unique_key = f"view_type_{query_hash}_{df_hash}"
    
    view_type = st.radio("Tampilan:", ["📋 List", "📊 Perbandingan"], 
                        horizontal=True, key=unique_key)
    
    if view_type == "📋 List":
        display_phone_list(df)
    else:  # Perbandingan
        if len(df) >= 2:
            st.markdown("### 📊 Perbandingan Spesifikasi")
            viz_engine.create_comparison_chart(df)
            
            # Tambahan: Tampilkan scatter plot jika data cukup
            if len(df) >= 5:
                st.markdown("### 📈 Analisis Harga vs Performa") 
                viz_engine.create_price_performance_scatter(df)
        else:
            st.warning("⚠️ Butuh minimal 2 HP untuk perbandingan. Menampilkan dalam format list.")
            display_phone_list(df)

def display_phone_cards(df: pd.DataFrame):
    """Display phones in card format"""
    for idx, (_, phone) in enumerate(df.iterrows()):
        if idx % 3 == 0:
            cols = st.columns(3)

        with cols[idx % 3]:
            create_phone_card(phone)

def display_phone_list(df: pd.DataFrame):
    """Display phones in detailed list format"""
    for idx, (_, phone) in enumerate(df.iterrows()):
        create_detailed_phone_card(phone, idx + 1)

def create_phone_card(phone):
    """Create individual phone card"""
    price_formatted = f"Rp {phone['Price']/1000000:.1f}M" if phone['Price'] > 0 else "N/A"

    st.markdown(f"""
    <div class="phone-card">
        <h3>📱 {phone['Company Name']} {phone['Model Name']}</h3>
        <div style="margin: 1rem 0;">
            <span style="background: #667eea; color: white; padding: 0.25rem 0.5rem; border-radius: 15px; font-size: 0.8rem; margin-right: 0.5rem;">
                💾 {phone['RAM']:.0f} GB
            </span>
            <span style="background: #45B7D1; color: white; padding: 0.25rem 0.5rem; border-radius: 15px; font-size: 0.8rem; margin-right: 0.5rem;">
                📸 {phone['Back Camera MP']:.0f} MP
            </span>
            <span style="background: #96CEB4; color: white; padding: 0.25rem 0.5rem; border-radius: 15px; font-size: 0.8rem;">
                🔋 {phone['Battery Extracted']:.0f} mAh
            </span>
        </div>
        <h4 style="color: #667eea; margin: 0.5rem 0;">💰 {price_formatted}</h4>
        <p style="color: #666; font-size: 0.9rem; margin-top: 0.5rem;">
            📱 {phone['Screen Size']:.1f}" | ⚖️ {phone['Weight']:.0f}g | 📅 {phone['Launched Year']:.0f}
        </p>
    </div>
    """, unsafe_allow_html=True)

def create_detailed_phone_card(phone, rank):
    """Create detailed phone card with ranking"""
    price_formatted = f"Rp {phone['Price']/1000000:.1f}M" if phone['Price'] > 0 else "N/A"

    with st.container():
        st.markdown(f"""
        <div style="background: white; padding: 1.5rem; border-radius: 10px; margin: 1rem 0;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1); border-left: 4px solid #667eea;">
            <div style="display: flex; align-items: center; margin-bottom: 1rem;">
                <span style="background: #667eea; color: white; border-radius: 50%;
                           width: 30px; height: 30px; display: flex; align-items: center;
                           justify-content: center; font-weight: bold; margin-right: 1rem;">
                    {rank}
                </span>
                <h3 style="margin: 0; color: #333;">📱 {phone['Company Name']} {phone['Model Name']}</h3>
            </div>
        """, unsafe_allow_html=True)

        col1, col2, col3 = st.columns(3)

        with col1:
            st.markdown("**💾 Memori & Performa**")
            st.write(f"• RAM: {phone['RAM']:.0f} GB")
            st.write(f"• Tahun: {phone['Launched Year']:.0f}")

        with col2:
            st.markdown("**📸 Kamera & Layar**")
            st.write(f"• Kamera: {phone['Back Camera MP']:.0f} MP")
            st.write(f"• Layar: {phone['Screen Size']:.1f} inci")

        with col3:
            st.markdown("**🔋 Baterai & Fisik**")
            st.write(f"• Baterai: {phone['Battery Extracted']:.0f} mAh")
            st.write(f"• Berat: {phone['Weight']:.0f} gram")

        st.markdown(f"""
            <div style="text-align: center; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #eee;">
                <h3 style="color: #667eea; margin: 0;">💰 {price_formatted}</h3>
            </div>
        </div>
        """, unsafe_allow_html=True)

def render_analytics_page(df: pd.DataFrame, viz_engine: VisualizationEngine):
    """Render analytics page"""
    st.markdown('<p class="header-text">Analytics & Insights</p>', unsafe_allow_html=True)

    if df.empty:
        st.error("Data tidak tersedia untuk analisis.")
        return

    # Analytics tabs
    tab1, tab2, tab3, tab4 = st.tabs(["📈 Tren Pasar", "🏆 Brand Analysis", "💰 Price Analysis", "⚡ Performance"])

    with tab1:
        render_market_trends(df)

    with tab2:
        render_brand_analysis(df)

    with tab3:
        render_price_analysis(df)

    with tab4:
        render_performance_metrics(df)

def render_market_trends(df: pd.DataFrame):
    """Render market trends analysis"""
    st.markdown("### 📈 Tren Pasar Smartphone")

    # Yearly trends
    yearly_stats = df.groupby('Launched Year').agg({
        'Model Name': 'count',
        'Price': 'mean',
        'RAM': 'mean',
        'Back Camera MP': 'mean',
        'Battery Extracted': 'mean'
    }).round(2)

    fig = make_subplots(
        rows=2, cols=2,
        subplot_titles=('Jumlah Model per Tahun', 'Rata-rata Harga per Tahun',
                       'Rata-rata RAM per Tahun', 'Rata-rata Kamera per Tahun'),
        specs=[[{"secondary_y": False}, {"secondary_y": False}],
               [{"secondary_y": False}, {"secondary_y": False}]]
    )

    # Add traces
    fig.add_trace(go.Scatter(x=yearly_stats.index, y=yearly_stats['Model Name'],
                            mode='lines+markers', name='Jumlah Model'), row=1, col=1)

    fig.add_trace(go.Scatter(x=yearly_stats.index, y=yearly_stats['Price']/1000000,
                            mode='lines+markers', name='Harga (Juta)'), row=1, col=2)

    fig.add_trace(go.Scatter(x=yearly_stats.index, y=yearly_stats['RAM'],
                            mode='lines+markers', name='RAM (GB)'), row=2, col=1)

    fig.add_trace(go.Scatter(x=yearly_stats.index, y=yearly_stats['Back Camera MP'],
                            mode='lines+markers', name='Kamera (MP)'), row=2, col=2)

    fig.update_layout(height=600, showlegend=False, template='plotly_white')
    st.plotly_chart(fig, use_container_width=True)

def render_brand_analysis(df: pd.DataFrame):
    """Render brand analysis"""
    st.markdown("### 🏆 Analisis Brand")

    brand_stats = df.groupby('Company Name').agg({
        'Model Name': 'count',
        'Price': ['mean', 'min', 'max'],
        'RAM': 'mean',
        'Back Camera MP': 'mean'
    }).round(2)

    # Flatten column names
    brand_stats.columns = ['_'.join(col).strip() for col in brand_stats.columns]
    brand_stats = brand_stats.reset_index()

    col1, col2 = st.columns(2)

    with col1:
        # Market share pie chart
        fig_pie = px.pie(brand_stats, values='Model Name_count', names='Company Name',
                        title='Market Share (Jumlah Model)')
        st.plotly_chart(fig_pie, use_container_width=True)

    with col2:
        # Average price by brand
        fig_bar = px.bar(brand_stats.head(10), x='Company Name', y='Price_mean',
                        title='Rata-rata Harga per Brand')
        # Perbaikan: gunakan update_layout bukan update_xaxis
        fig_bar.update_layout(xaxis={'tickangle': 45})
        st.plotly_chart(fig_bar, use_container_width=True)

def render_price_analysis(df: pd.DataFrame):
    """Render price analysis"""
    st.markdown("### 💰 Analisis Harga")

    # Price distribution
    fig_hist = px.histogram(df, x='Price', nbins=30, title='Distribusi Harga Smartphone')
    # Perbaikan: gunakan update_layout bukan update_xaxis/update_yaxis
    fig_hist.update_layout(
        xaxis_title='Harga (IDR)',
        yaxis_title='Jumlah Model'
    )
    st.plotly_chart(fig_hist, use_container_width=True)

    # Price vs specifications correlation
    col1, col2 = st.columns(2)

    with col1:
        fig_scatter1 = px.scatter(df, x='RAM', y='Price', color='Company Name',
                                 title='Harga vs RAM', trendline='ols')
        st.plotly_chart(fig_scatter1, use_container_width=True)

    with col2:
        fig_scatter2 = px.scatter(df, x='Back Camera MP', y='Price', color='Company Name',
                                 title='Harga vs Kamera', trendline='ols')
        st.plotly_chart(fig_scatter2, use_container_width=True)

def render_performance_metrics(df: pd.DataFrame):
    """Render performance metrics"""
    st.markdown("### ⚡ Metrik Performa")

    # Performance scoring
    df_perf = df.copy()
    df_perf['Performance Score'] = (
        df_perf['RAM'] * 0.3 +
        df_perf['Back Camera MP'] * 0.2 +
        df_perf['Battery Extracted'] / 100 * 0.3 +
        (2025 - df_perf['Launched Year']) * -2 * 0.2
    )

    # Top performers
    top_performers = df_perf.nlargest(10, 'Performance Score')

    fig = px.bar(top_performers, x='Performance Score',
                y=[f"{row['Company Name']} {row['Model Name']}" for _, row in top_performers.iterrows()],
                orientation='h', title='Top 10 Smartphone Berperforma Tinggi')
    fig.update_layout(height=500)
    st.plotly_chart(fig, use_container_width=True)

    # Performance vs Price scatter
    fig_scatter = px.scatter(df_perf, x='Performance Score', y='Price',
                           size='Screen Size', color='Company Name',
                           hover_name='Model Name', title='Performa vs Harga')
    st.plotly_chart(fig_scatter, use_container_width=True)

def render_about_page():
    """Render about page"""
    st.markdown('<p class="header-text">Tentang PickAPhone</p>', unsafe_allow_html=True)

    col1, col2 = st.columns([2, 1])

    with col1:
        st.markdown("""
        ### 🚀 Tentang Aplikasi

        **PickAPhone AI** adalah aplikasi rekomendasi smartphone yang memanfaatkan kecerdasan buatan
        untuk membantu Anda menemukan HP yang sesuai dengan kebutuhan dan budget.

        ### ✨ Fitur Utama:
        - **🤖 AI-Powered Search**: Cari HP dengan bahasa natural
        - **📊 Advanced Analytics**: Analisis mendalam tentang pasar smartphone
        - **🔄 Real-time Comparison**: Bandingkan spesifikasi secara detail
        - **💡 Smart Recommendations**: Rekomendasi personal berdasarkan kebutuhan

        ### 🛠️ Teknologi:
        - **Streamlit**: Framework aplikasi web
        - **OpenRouter API**: LLM engine untuk pemahaman bahasa natural
        - **Plotly**: Visualisasi data interaktif
        - **Pandas**: Manipulasi dan analisis data

        ### 📈 Dataset:
        Aplikasi ini menggunakan dataset smartphone terbaru dengan lebih dari 800+ model
        dari berbagai brand populer dengan spesifikasi lengkap dan harga terkini.
        """)

    with col2:
        st.markdown("""
        ### 📞 Kontak

        **Developer**: Team 28 Capstone Data Science

        **Email**: capstone28@student.telkomuniversity.ac.id

        **Version**: 2.0
        
        **Last Update**: 2025

        ### ⭐ Rating
        Berikan rating untuk aplikasi ini!
        """)

        rating = st.select_slider(
            "Rating",
            options=[1, 2, 3, 4, 5],
            value=5,
            format_func=lambda x: "⭐" * x
        )

        if st.button("Submit Rating"):
            st.success(f"Terima kasih! Rating: {'⭐' * rating}")

if __name__ == "__main__":
    main()
